---
title: "sc_protocol_basic"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library('pagoda2')
library(Matrix)
library(colorRamps)


# useful globals
get_goSets_func = NULL
get_go_env = NULL
org = NULL
```

# Data set choice:
```{r}

## Data set options:   un-comment just one of them.

##########################################
# human peripheral blood mononuclear cells
#counts_matrix_filename = "data/pbmcs/pbmc3k.counts.matrix.gz"; org="human"

#############################
# human fetal neocortex cells
#counts_matrix_filename = "data/fetal_neocortex/GSE75140_hOrg.fetal.counts.matrix.gz"; org="human"



##############################
# mouse retinal bipolar cells
counts_matrix_filename = "data/retinal_bipolar_cells/retinal_bipolar.dat.gz"; org="mouse"

```



```{r}

if (org == "human") {
  get_goSets_func = p2.generate.human.go.web
  get_go_env = p2.generate.human.go
  suppressMessages(library(org.Hs.eg.db))
  ALIAS2EG = org.Hs.egALIAS2EG
} else if (org == "mouse") {
  get_goSets_func = p2.generate.mouse.go.web
  get_go_env = pagoda2:::p2.generate.mouse.go
  suppressMessages(library(org.Mm.eg.db))
  ALIAS2EG = org.Mm.egALIAS2EG
} else {
  stop("Error, not sure what organism we're using")
}
```

##############################
# Data preparation
##############################

```{r}
# Read data from your file, rows as genes colums as cells
myCountMatrix <- read.table(gzfile(counts_matrix_filename), header=T, row.names=1)
```

Look at the matrix:
```{r}
myCountMatrix[1:10, 1:3]
```

How big is the matrix?

```{r}
dim(myCountMatrix) # report num rows and cols
```

Size in bytes?
```{r}
object.size(myCountMatrix)
```

Convert the matrix to a sparse matrix
```{r}
myCountMatrixSparse <- Matrix(as.matrix(myCountMatrix), sparse = T)

# check dimensions:
dim(myCountMatrixSparse)

# check size:
object.size(myCountMatrixSparse)

# size reduction:
object.size(myCountMatrixSparse) / object.size(myCountMatrix)

```



```{r}
# Remove the original matrix to reduce memory usage
rm(myCountMatrix)
myCountMatrixSparse.prefiltered = myCountMatrixSparse # store just in case
```

## Filtering 'bad' cells

Look at the summary counts

```{r}
#par(mfrow=c(1,2), mar = c(3.5,3.5,2.0,0.5), mgp = c(2,0.65,0), cex = 1.0)

reads_per_cell = Matrix::colSums(myCountMatrixSparse)
reads_per_gene = Matrix::rowSums(myCountMatrixSparse)
genes_per_cell = Matrix::colSums(myCountMatrixSparse>0) # count gene only if it has non-zero reads mapped.
cells_per_gene = Matrix::rowSums(myCountMatrixSparse>0) # only count cells where the gene is expressed

hist(log10(reads_per_cell+1),main='reads per cell',col='wheat')
hist(log10(genes_per_cell+1), main='genes per cell', col='wheat')
plot(reads_per_cell, genes_per_cell, log='xy', col='wheat')
hist(log10(reads_per_gene+1),main='reads per gene',col='wheat')
```

```{r}
plot(sort(genes_per_cell), xlab='cell', log='y', main='genes per cell (ordered)')

# can set upper and lower thresholds for genes per cell:
# abline(h=300, col='green')  # lower threshold
# abline(h=1400, col='green') # upper threshold
```

Examine percent mitochondrial read content

```{r}
# define the mitochondrial genes
mito_genes = grep("^mt-", rownames(myCountMatrixSparse) , ignore.case=T, value=T)
print(mito_genes)
```
```{r}
# compute pct mito
mito_gene_read_counts = Matrix::colSums(myCountMatrixSparse[mito_genes,])
pct_mito = mito_gene_read_counts / reads_per_cell * 100
plot(sort(pct_mito))
abline(h=10, col='red')
```



```{r}
df = data.frame(reads_per_cell=reads_per_cell, genes_per_cell=genes_per_cell)
head(df)
```

```{r}
# cell selection as per Peter Karchenko - the Pagoda way.
library(MASS)
plot(df, log='xy')
m <- rlm(genes_per_cell~reads_per_cell,data=df)
p.level = 1e-3
suppressWarnings(pb <- data.frame(predict(m,interval='prediction',level = 1-p.level,type="response")))
polygon(c(df$reads_per_cell,rev(df$reads_per_cell)),c(pb$lwr,rev(pb$upr)),col=adjustcolor(2,alpha=0.1),border = NA)
outliers <- rownames(df)[df$genes_per_cell > pb$upr | df$genes_per_cell < pb$lwr];
points(df[outliers,],col=2,cex=0.6)
```



Based on the above, decide on thresholds for filtering out cells and genes:

```{r}
myCountMatrixSparse = myCountMatrixSparse.prefiltered # just in case we re-run this block using different thresholds.

###############################################################
# prune genes, require a gene to be expressed in at least 3 cells
myCountMatrixSparse.prefiltered = myCountMatrixSparse
myCountMatrixSparse = myCountMatrixSparse[cells_per_gene >= 3,]

###############################################################
# prune cells
valid_cells = colnames(myCountMatrixSparse) # all cells
length(valid_cells) # number starting with

## remove cells based on gene count criteria:
valid_cells = valid_cells[genes_per_cell >= 300 & genes_per_cell <= 1400]  # set values based on your evaluation above
length(valid_cells) # number after filtering based gene count thresholds

## remove cells identified as outliers via the Karchenko method
valid_cells = valid_cells[ ! valid_cells %in% outliers]
length(valid_cells) # number surviving outlier detection

## update the count matrix to contain only the valid cells
myCountMatrixSparse = myCountMatrixSparse[,valid_cells]
```


##############################
# Seurat2
##############################

```{r}
library(Seurat)
seurat2obj = CreateSeuratObject(raw.data=myCountMatrixSparse)
```





```{r}
##############################
# Pagoda2 - 
##############################

# Generate a new pagoda2 object
myPagoda2Object <- Pagoda2$new(x = myCountMatrixSparse, n.cores = 4)

# Adjust the variance
myPagoda2Object$adjustVariance(plot = T, gam.k = 10)


# Calculate a PCA reduction with the number of PCs specified by nPCs
# and using only the n.odgenes overdispersed genes -- in this case 2000
myPagoda2Object$calculatePcaReduction(nPcs = 100, n.odgenes = 2.e3)

# Generate K-nearest neighbour graph
myPagoda2Object$makeKnnGraph(k = 20, type = 'PCA', center = T,
    weight.type = 'none', n.cores = 30, distance = 'cosine')


```

```{r}

##############################
# Identify clusters
##############################

# Identify clusters using the infomap.community method
# on the basis of the reduction called 'PCA' (generated above)
# Save the resulting clustering as 'infomap'
myPagoda2Object$getKnnClusters(method = infomap.community,
                               type = 'PCA', name = 'infomap')
                               
# Do an independent identification of clusters using the
# multilevel community algorithm again using the PCA reduction
# and save it as 'multilevel'. This does not overwrite the 
# previous clustering
myPagoda2Object$getKnnClusters(method = multilevel.community,
                               type = 'PCA', name='multilevel')
                               
# Do yet another clustering
myPagoda2Object$getKnnClusters(method = walktrap.community,
                               type = 'PCA', name='walktrap')

```


```{r}
##############################
# Generate embeddings
##############################
# Generate an embedding with largeVis on the basis of the PCA reduction
M <- 30
myPagoda2Object$getEmbedding(
  type = 'PCA',
  embeddingType = 'largeVis',
  M = M,
  perplexity = 30,
  gamma = 1 / M,
  alpha = 1
)

# Generate an embedding with tSNE on the basis of the PCA
# reduction
myPagoda2Object$getEmbedding(type = 'PCA', embeddingType = 'tSNE')

```

```{r}

##############################
# Plot the generated embeddings
##############################
myPagoda2Object$plotEmbedding(type = 'PCA',
                              embedding = 'largeVis',
                              mark.clusters = T,
                              clusterType = 'infomap')
                              
                              
myPagoda2Object$plotEmbedding(type = 'PCA',
                              embedding = 'largeVis',
                              mark.clusters = T,
                              clusterType = 'multilevel')

myPagoda2Object$plotEmbedding(type = 'PCA',
                              embedding = 'largeVis',
                              mark.clusters = T,
                              clusterType = 'walktrap')


myPagoda2Object$plotEmbedding(type = 'PCA',
                              clusterType = 'infomap',
                              embeddingType = 'tSNE',
                              mark.clusters = T)


```


```{r}
##############################
# Differential Gene expression
##############################

# Calculate the differential gene expression of each cluster
# defined in multilevel clustring on the basis of the PCA reduction
myPagoda2Object$getDifferentialGenes(type='PCA',clusterType = 'multilevel')

# Plot a differential expression heatmap using the differentially expressed genes
# above
myPagoda2Object$plotDiffGeneHeatmap(type = 'PCA', clusterType = 'multilevel')

```


```{r}
# Pathway overdispersion -- required for web
go.env <- get_go_env(myPagoda2Object)

myPagoda2Object$testPathwayOverdispersion(setenv = go.env, verbose = T, correlation.distance.threshold = 0.9, 
                                          recalculate.pca = F,
                                          min.pathway.size = 100, max.pathway.size = 1000)

```

```{r}
################################
# Generate the web application
################################

# Generate GO genesets for the web app
myGeneNames <- colnames(myPagoda2Object$counts)
goSets <- get_goSets_func(myGeneNames)

# Generate differental expression between each cluster and everything else
# Load these clusters as pre-defined gene sets with the given prefix
deSets <- get.de.geneset(myPagoda2Object, groups = myPagoda2Object$clusters$PCA[[1]], prefix = 'de_')

# Merge Genesets
geneSets <- c(goSets, deSets)

```


```{r}
# Additional metadata generation
additionalMetadata <- list()

additionalMetadata$altCluster <- p2.metadata.from.factor(myPagoda2Object$clusters$PCA[[1]], displayname = 'Infomap', s = 0.7, v = 0.8,start = 0, end = 0.5)

additionalMetadata$altCluster <- p2.metadata.from.factor(myPagoda2Object$clusters$PCA[[2]], displayname = 'Multilevel', s = 0.7, v = 0.8,start = 0, end = 0.5)

```


```{r}
# Set the palette manually for Walktrap
a <- myPagoda2Object$clusters$PCA[[3]]
p1 <- colorRamps::primary.colors(n = nlevels(a))
names(p1) <- levels(a)
#additionalMetadata$altCluster2 <- p2.metadata.from.factor(myPagoda2Object$clusters$PCA[[3]], displayname = 'Walktrap', pal = 1)  # bhaas: had to remove pal=1 to avoid error:
#     Error in p2.metadata.from.factor(myPagoda2Object$clusters$PCA[[3]], displayname = "Walktrap",  : 
#  The provided palette contains a different number of colours from the levels in the metadata

additionalMetadata$altCluster2 <- p2.metadata.from.factor(myPagoda2Object$clusters$PCA[[3]], displayname = 'Walktrap')
```



```{r}
# Generate the gene knn graph, which is used to find gene with similar expression patterns
# This step is required for web object serialisation with the serializeToStaticFast() function

#myPagoda2Object$geneKnnbyPCA()
#  bhaas:  above command generated error:
#    Error in warn("geneKnnbyPCA is deprecated use makeGeneKnnGraph() instead") : 
#        could not find function "warn"

# instead, running what the error message recommends:
myPagoda2Object$makeGeneKnnGraph()
```

```{r}
# Generate and display web app
myPagoda2WebObject <-
  make.p2.app(
    myPagoda2Object,
    dendrogramCellGroups = myPagoda2Object$clusters$PCA[[1]],
    additionalMetadata = additionalMetadata,
    geneSets = geneSets,
    show.clusters = FALSE, # Hide the clusters that were used for the dendrogram from the metadata
  )

```

# For matching server env
#rm(myPagoda2Object); # The original object is no longer required

# This step is optional, it is required if the app is loaded from 
# disk on another machine where the installation of the R package
# is on another directory
# myPagoda2WebObject$updateRookRoot();

```{r}
# Show the app
show.app(app=myPagoda2WebObject,name='p2Sample1')
```


```{r}

## try to set up for pagoda2-hierarchical marker identification

r=myPagoda2Object


# translate gene names to ids
ids <- unlist(lapply(mget(colnames(r$counts),ALIAS2EG,ifnotfound=NA),function(x) x[1]))
# reverse map
rids <- names(ids); names(rids) <- ids;
# list all the ids per GO category
go.env <- list2env(eapply(ALIAS2EG,function(x) as.character(na.omit(rids[x]))))

r$testPathwayOverdispersion(go.env,verbose=T,correlation.distance.threshold=0.95,recalculate.pca=F,top.aspects=15)

r$getHierarchicalDiffExpressionAspects(type='PCA',clusterName='walktrap',z.threshold=3)
```

```{r}
app2 <- p2.make.pagoda1.app(r,inner.clustering=TRUE,embeddingType='tSNE',clusterType='walktrap',min.group.size=50,row.clustering=list(order=rev(1:nrow(r$misc$pathwayOD$xv))))
```


```{r}
show.app(app2,'p2hierarchical',browse=T)
```


####################################
## App Loading #####################
####################################

## Pagoda app-style 1

```{r}  
show.app(app=myPagoda2WebObject,name='p2Sample1')
```

## Pagoda app-style 2
```{r}
show.app(app2,'p2hierarchical',browse=T)
```


