---
title: "sc_protocol_basic"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library('pagoda2')
library(Matrix)
library(colorRamps)


# useful globals
get_goSets_func = NULL
get_go_env = NULL
org = NULL
```

# Data set choice:
```{r}

## Data set options:   un-comment just one of them.

##########################################
# human peripheral blood mononuclear cells
#counts_matrix_filename = "data/pbmcs/pbmc3k.counts.matrix.gz"; org="human"

#############################
# human fetal neocortex cells
#counts_matrix_filename = "data/fetal_neocortex/GSE75140_hOrg.fetal.counts.matrix.gz"; org="human"



##############################
# mouse retinal bipolar cells
counts_matrix_filename = "data/retinal_bipolar_cells/retinal_bipolar.dat.gz"; org="mouse"

```



```{r}

if (org == "human") {
  get_goSets_func = p2.generate.human.go.web
  get_go_env = p2.generate.human.go
  suppressMessages(library(org.Hs.eg.db))
  ALIAS2EG = org.Hs.egALIAS2EG
} else if (org == "mouse") {
  get_goSets_func = p2.generate.mouse.go.web
  get_go_env = pagoda2:::p2.generate.mouse.go
  suppressMessages(library(org.Mm.eg.db))
  ALIAS2EG = org.Mm.egALIAS2EG
} else {
  stop("Error, not sure what organism we're using")
}
```


```{r}

##############################
# Data preparation
##############################

# Read data from your file, rows as genes colums as cells
myCountMatrix <- read.table(gzfile(counts_matrix_filename), header=T, row.names=1)

# Make the gene name unique
#rownames(myCountMatrix) <- make.unique(rownames(myCountMatrix))

# Conver the matrix to a sparse matrix
myCountMatrixSparse <- Matrix(as.matrix(myCountMatrix), sparse = T)

# Remove the original matrix
rm(myCountMatrix)

```


```{r}
##############################
# Process the data
##############################

# Generate a new pagoda2 object
myPagoda2Object <- Pagoda2$new(x = myCountMatrixSparse, n.cores = 4)

# Adjust the variance
myPagoda2Object$adjustVariance(plot = T, gam.k = 10)


# Calculate a PCA reduction with the number of PCs specified by nPCs
# and using only the n.odgenes overdispersed genes -- in this case 2000
myPagoda2Object$calculatePcaReduction(nPcs = 100, n.odgenes = 2.e3)

# Generate K-nearest neighbour graph
myPagoda2Object$makeKnnGraph(k = 20, type = 'PCA', center = T,
    weight.type = 'none', n.cores = 30, distance = 'cosine')


```

```{r}

##############################
# Identify clusters
##############################

# Identify clusters using the infomap.community method
# on the basis of the reduction called 'PCA' (generated above)
# Save the resulting clustering as 'infomap'
myPagoda2Object$getKnnClusters(method = infomap.community,
                               type = 'PCA', name = 'infomap')
                               
# Do an independent identification of clusters using the
# multilevel community algorithm again using the PCA reduction
# and save it as 'multilevel'. This does not overwrite the 
# previous clustering
myPagoda2Object$getKnnClusters(method = multilevel.community,
                               type = 'PCA', name='multilevel')
                               
# Do yet another clustering
myPagoda2Object$getKnnClusters(method = walktrap.community,
                               type = 'PCA', name='walktrap')

```


```{r}
##############################
# Generate embeddings
##############################
# Generate an embedding with largeVis on the basis of the PCA reduction
M <- 30
myPagoda2Object$getEmbedding(
  type = 'PCA',
  embeddingType = 'largeVis',
  M = M,
  perplexity = 30,
  gamma = 1 / M,
  alpha = 1
)

# Generate an embedding with tSNE on the basis of the PCA
# reduction
myPagoda2Object$getEmbedding(type = 'PCA', embeddingType = 'tSNE')

```

```{r}

##############################
# Plot the generated embeddings
##############################
myPagoda2Object$plotEmbedding(type = 'PCA',
                              embedding = 'largeVis',
                              mark.clusters = T,
                              clusterType = 'infomap')
                              
                              
myPagoda2Object$plotEmbedding(type = 'PCA',
                              embedding = 'largeVis',
                              mark.clusters = T,
                              clusterType = 'multilevel')

myPagoda2Object$plotEmbedding(type = 'PCA',
                              embedding = 'largeVis',
                              mark.clusters = T,
                              clusterType = 'walktrap')


myPagoda2Object$plotEmbedding(type = 'PCA',
                              clusterType = 'infomap',
                              embeddingType = 'tSNE',
                              mark.clusters = T)


```


```{r}
##############################
# Differential Gene expression
##############################

# Calculate the differential gene expression of each cluster
# defined in multilevel clustring on the basis of the PCA reduction
myPagoda2Object$getDifferentialGenes(type='PCA',clusterType = 'multilevel')

# Plot a differential expression heatmap using the differentially expressed genes
# above
myPagoda2Object$plotDiffGeneHeatmap(type = 'PCA', clusterType = 'multilevel')

```


```{r}
# Pathway overdispersion -- required for web
go.env <- get_go_env(myPagoda2Object)

myPagoda2Object$testPathwayOverdispersion(setenv = go.env, verbose = T, correlation.distance.threshold = 0.9, 
                                          recalculate.pca = F,
                                          min.pathway.size = 100, max.pathway.size = 1000)

```

```{r}
################################
# Generate the web application
################################

# Generate GO genesets for the web app
myGeneNames <- colnames(myPagoda2Object$counts)
goSets <- get_goSets_func(myGeneNames)

# Generate differental expression between each cluster and everything else
# Load these clusters as pre-defined gene sets with the given prefix
deSets <- get.de.geneset(myPagoda2Object, groups = myPagoda2Object$clusters$PCA[[1]], prefix = 'de_')

# Merge Genesets
geneSets <- c(goSets, deSets)

```


```{r}
# Additional metadata generation
additionalMetadata <- list()

additionalMetadata$altCluster <- p2.metadata.from.factor(myPagoda2Object$clusters$PCA[[1]], displayname = 'Infomap', s = 0.7, v = 0.8,start = 0, end = 0.5)

additionalMetadata$altCluster <- p2.metadata.from.factor(myPagoda2Object$clusters$PCA[[2]], displayname = 'Multilevel', s = 0.7, v = 0.8,start = 0, end = 0.5)

```


```{r}
# Set the palette manually for Walktrap
a <- myPagoda2Object$clusters$PCA[[3]]
p1 <- colorRamps::primary.colors(n = nlevels(a))
names(p1) <- levels(a)
#additionalMetadata$altCluster2 <- p2.metadata.from.factor(myPagoda2Object$clusters$PCA[[3]], displayname = 'Walktrap', pal = 1)  # bhaas: had to remove pal=1 to avoid error:
#     Error in p2.metadata.from.factor(myPagoda2Object$clusters$PCA[[3]], displayname = "Walktrap",  : 
#  The provided palette contains a different number of colours from the levels in the metadata

additionalMetadata$altCluster2 <- p2.metadata.from.factor(myPagoda2Object$clusters$PCA[[3]], displayname = 'Walktrap')
```



```{r}
# Generate the gene knn graph, which is used to find gene with similar expression patterns
# This step is required for web object serialisation with the serializeToStaticFast() function

#myPagoda2Object$geneKnnbyPCA()
#  bhaas:  above command generated error:
#    Error in warn("geneKnnbyPCA is deprecated use makeGeneKnnGraph() instead") : 
#        could not find function "warn"

# instead, running what the error message recommends:
myPagoda2Object$makeGeneKnnGraph()
```

```{r}
# Generate and display web app
myPagoda2WebObject <-
  make.p2.app(
    myPagoda2Object,
    dendrogramCellGroups = myPagoda2Object$clusters$PCA[[1]],
    additionalMetadata = additionalMetadata,
    geneSets = geneSets,
    show.clusters = FALSE, # Hide the clusters that were used for the dendrogram from the metadata
  )

```

# For matching server env
#rm(myPagoda2Object); # The original object is no longer required

# This step is optional, it is required if the app is loaded from 
# disk on another machine where the installation of the R package
# is on another directory
# myPagoda2WebObject$updateRookRoot();

```{r}
# Show the app
show.app(app=myPagoda2WebObject,name='p2Sample1')
```


```{r}

## try to set up for pagoda2-hierarchical marker identification

r=myPagoda2Object


# translate gene names to ids
ids <- unlist(lapply(mget(colnames(r$counts),ALIAS2EG,ifnotfound=NA),function(x) x[1]))
# reverse map
rids <- names(ids); names(rids) <- ids;
# list all the ids per GO category
go.env <- list2env(eapply(ALIAS2EG,function(x) as.character(na.omit(rids[x]))))

r$testPathwayOverdispersion(go.env,verbose=T,correlation.distance.threshold=0.95,recalculate.pca=F,top.aspects=15)

r$getHierarchicalDiffExpressionAspects(type='PCA',clusterName='walktrap',z.threshold=3)
```

```{r}
app2 <- p2.make.pagoda1.app(r,inner.clustering=TRUE,embeddingType='tSNE',clusterType='walktrap',min.group.size=50,row.clustering=list(order=rev(1:nrow(r$misc$pathwayOD$xv))))
```


```{r}
show.app(app2,'p2hierarchical',browse=T)
```


####################################
## App Loading #####################
####################################

## Pagoda app-style 1

```{r}  
show.app(app=myPagoda2WebObject,name='p2Sample1')
```

## Pagoda app-style 2
```{r}
show.app(app2,'p2hierarchical',browse=T)
```


